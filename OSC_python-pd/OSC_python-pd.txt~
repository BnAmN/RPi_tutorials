Alright, today's topic will be... using OSC between python and Pure Data!

// Context
Once again I'm using the Raspberry Pi to do some cool stuff. The idea here is to collect data from sensors and use them to generate sound synthesis.
Tricky part is: data is collected using python (using python's RPi.GPIO https://pypi.python.org/pypi/RPi.GPIO) while sound synthesis is generated with pure data. We therefore need to make them communicate with each other.
To do so we're gonna use Open Sound Control (OSC).

If you want to know more on the subject of OSC I recommend you take a look either here : http://opensoundcontrol.org/ or there : http://en.wikipedia.org/wiki/Open_Sound_Control .

// How to install everything
Let's start with python.
To achieve this goal I chose to use pyOSC.
You can find it directly on gitorious : http://gitorious.org/pyosc .
Once in your Raspberry Pi start by cloning it:
	git clone git://gitorious.org/pyosc/devel.git
Installation is then quite simple :
	sudo ./setup.py install

Once this is done we can move to Pure Data.
If you're using Pd-extended you won't have to deal with that part. 
For those, like me, who use pd vanilla, here is what needs to be done.

First, let's install the iemnet lib which is needed to deal with data transfer (to do so you will need git) : 
	git clone git://github.com/umlaeute/pd-iemnet.git
(alternatively, you can go on https://github.com/umlaeute/pd-iemnet and download the zip file)
You should also be able to download it on the pure data website : http://puredata.info/downloads/iemnet . Nevertheless, I've had problems trying to compile it.
After cloning the repository it simply goes this way :
	cd pd-iemnet
	sudo make
	sudo make install

We then need one last component which is the one managing OSC messages. This library is simply called OSC and compilling it goes this way:
	wget http://puredata.info/downloads/osc/releases/0.1/OSC-0.1.tar.gz
	tar -xzvf OSC-0.1.tar.gz 
	cd OSC-0.1/
	make
	sudo make install

That's all we need this far, time to move on to the actual fun!

// How the code works

Once again, let's start with python.
The code is quite simple : 

#! /usr/bin/python

import OSC
import time

# Init OSC
client = OSC.OSCClient()
client.connect(('127.0.0.1', 9001)) # first argument is the IP of the host, second argument the port to use

try:
	client.send(OSC.OSCMessage("/adress", data) # first argument is the what we could call the OSC adress of the data, second argument is the actual data to be sent.
except:
	print "not connected"
        pass

On the pure data side, receiving data is quite simple too : 

#N canvas 565 294 450 300 10;
#X obj 186 62 iemnet/udpreceive 9001;
#X obj 186 84 OSC/unpackOSC;
#X obj 186 106 OSC/routeOSC /lamp;
#X obj 186 128 print;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;

Launch both on them on your RPi and it should work just fine!

You can notice that my pd objects specify the library they are using (ie: OSC/...). With pd-extended this won't be needed. With pd vanilla and the startup path correctly set up it won't be needed either. 

Thus far we've been through everything we need to transmit data from python to pure data. Obviously it does work the other way around, from pd to python, but I didn't need it this far. I'll leave it to you to discover!













